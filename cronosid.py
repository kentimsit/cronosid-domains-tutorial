# Imports & set-up
from web3 import Web3
w3 = Web3(Web3.HTTPProvider("https://evm.cronos.org"))

# Broadly speaking, Cronos ID works in a way that is similar to other EVM
# domain systems like ENS.
# You may refer to the ENS docs for more details: https://docs.ens.domains/

#
# ********************************************************************************
#

# The following function is a utility which computes the 'node' corresponding
# to a defined domain, as defined in  https://eips.ethereum.org/EIPS/eip-137.
# The node is a hash associated with a domain, calculated according to EIP137 specifications.
# The hash is returned in bytes format.


def namehash(name):
    if name == '':
        return b'\0' * 32
    else:
        label, _, remainder = name.partition('.')
        return w3.keccak(namehash(remainder) + w3.keccak(text=label))

#
# ********************************************************************************
#

# The purpose of this function is to list the Cronos ID domains minted
# during a specific block range of the Cronos mainnet chain.


def list_domains_minted():
    # This is the hardcoded address of the smart contract which supports the Cronosid.xyz storefront
    minting_contract_address = Web3.toChecksumAddress(
        "0xAfF2b5CF1950E8Fb22907CcD643728a5Dc75278B")
    # This is the hash of the event generated by the contract when a new domain is minted
    minting_event_signature_hash = "0x69e37f151eb98a09618ddaa80c8cfaf1ce5996867c489f45b555b412271ebf27"
    block_start = 4932153
    # Let's capture all the events matching the contract address and event signature
    logs = w3.eth.get_logs({
        "fromBlock": block_start,
        "toBlock": block_start + 2000,
        "address": minting_contract_address,
        "topics": [
            minting_event_signature_hash
        ]
    })
    # Let's print the domains
    for log in logs:
        # The domain without CRO is encoded in bytes32 as 5th argument of the data field of the event
        data_without0x = log['data'][2:]
        data_spliced = [data_without0x[i:i+64]
                        for i in range(0, len(data_without0x), 64)]
        domain_name = bytes.fromhex(data_spliced[5]).decode(
            "utf-8", errors="replace").replace("\x00", "")
        print("At block", log['blockNumber'],
              "this domain was minted:", domain_name + ".cro")

#
# ********************************************************************************
#

# The purpose of the following code is to determine who is the owner
# of a given .cro domain name. This is called forward resolution.


# We start by importing an extract of the standard ABI of the Registry smart contract
registry_contract_abi = [{
    "constant": True,
    "inputs": [
        {
            "internalType": "bytes32",
            "name": "node",
            "type": "bytes32"
        }
    ],
    "name": "resolver",
    "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
    ],
    "payable": False,
    "stateMutability": "view",
    "type": "function"
},
    {
        "constant": True,
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "node",
                "type": "bytes32"
            }
        ],
        "name": "owner",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function"
}]

# Let's find the owner of a domain (given without the .cro suffix)


def forward_resolution(domain_without_cro):
    # Hardcoded address of the registry smart contract:
    registry_contract_address = Web3.toChecksumAddress(
        "0x7F4C61116729d5b27E5f180062Fdfbf32E9283E5")
    # We use the web3.py package to instantiate the smart contract:
    registry_contract = w3.eth.contract(
        registry_contract_address, abi=registry_contract_abi)
    # Calculate the node using the hash function provide above:
    node = namehash(domain_without_cro + ".cro").hex()
    # Call the 'owner" function of the registry, which returns the owner of the domain:
    return getattr(registry_contract.functions, 'owner')(node).call(block_identifier='latest')

#
# ********************************************************************************
#

# The purpose of the following code is to query the reverse registry in order to
# determine the domain associated with a wallet address, if it exists (happy path only).
# Per ENS guidelines, one must always check the forward registry to confirm that the
# address does own the corresponding domain name. Reverse resolution is not sufficient.

# We start by importing an extract of the standard ABI of the Resolver smart contract


resolver_contract_abi = [{
    "constant": True,
    "inputs": [
        {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
        }
    ],
    "name": "name",
    "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
    ],
    "payable": False,
    "stateMutability": "view",
    "type": "function"
}]


def reverse_resolution(owner):
    # First, we transform the owner's address into a domain name with the correct namespace.
    # This is just a convention set up by ENS for reverse lookup.
    derived_domain = owner.lower()[2:]+".addr.reverse"
    # Then, let's query the Registry to find the address of the resolver of this domain.
    # Hardcoded address of the registry smart contract:
    registry_contract_address = Web3.toChecksumAddress(
        "0x7F4C61116729d5b27E5f180062Fdfbf32E9283E5")
    # We use the web3.py package to instantiate the smart contract:
    registry_contract = w3.eth.contract(
        registry_contract_address, abi=registry_contract_abi)
    # Calculate the node hash from the domain:
    derived_node = namehash(derived_domain).hex()
    # Call the 'resolver" function of the registry to find the address of the
    # resolver smart contract associated with this domain:
    resolver = getattr(registry_contract.functions, 'resolver')(
        derived_node).call(block_identifier='latest')
    # Then instantiate the resolver smart contract:
    resolver_contract = w3.eth.contract(
        Web3.toChecksumAddress(resolver), abi=resolver_contract_abi)
    # Let's call the 'name' function of the resolver in order to find the corresponding domain:
    return getattr(resolver_contract.functions, 'name')(derived_node).call(block_identifier='latest')

#
# ********************************************************************************
#


if __name__ == '__main__':
    print("\n\nFirst let's have some fun.")
    print("\n\nWe are going to monitor the new domains minted within a specific block range.")
    print("(You can customize the block range manually in the code.)")
    list_domains_minted()
    domain_without_cro = "web3developer"
    print("\n\nNow, let's find the owner of domain", domain_without_cro + ".cro")
    owner = forward_resolution(domain_without_cro)
    print("The owner of", domain_without_cro + ".cro", "is", owner)
    print("\n\nNow we are going to reverse resolve the domain address of wallet", owner)
    reverse_resolved_domain = reverse_resolution(owner)
    print("The domain returned by the reverse resolution is",
          reverse_resolved_domain)
    print("\n\nBut we must complete the forward resolution too, as reverse resolution is not secure enough")
    reverse_resolved_domain_without_cro = reverse_resolved_domain.replace(
        ".cro", "")
    owner_verification = forward_resolution(
        reverse_resolved_domain_without_cro)
    print("The forward resolution of domain",
          reverse_resolved_domain_without_cro, "returns", owner_verification)
    if owner.lower() == owner_verification.lower():
        print("=> All good, we have verified that", owner,
              "is indeed the owner of", reverse_resolved_domain)
    else:
        print("=> Not good, the forward resolution is not consistent with the forward resolution")
    print("\nAnd we are done!")
